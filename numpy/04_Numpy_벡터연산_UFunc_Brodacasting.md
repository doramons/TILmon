#### 벡터화 - 벡터연산
    - 같은 형태의 배열(벡터,행렬)간의 연산은 같은 index의 원소끼리 연산을 한다
        - Element-wise(원소별) 연산이라고도 한다
        - 배열간의 연산시 배열의 형태(shape)가 같아야 한다
        - 배열의 형태가 다른 경우 Broadcast 조건을 만족하면 연산이 가능하다
        
##### 벡터/행렬과 스칼라간 연산

    - 해당 배열에 각각 스칼라 값이 연산된다

#### 내적 (Dot product)
    - @ 연산자 또는 numpy.dot(벡터/행렬, 벡터/행렬) 함수 사용
 ##### 벡터간의 내적
    - 같은 index의 원소끼리 곱한 뒤 결과를 모두 더한다
    - 벡터간의 내적의 결과는 스칼라가 된다
    - x·y 또는 x^Ty로 표현
    - 조건
        - 두 벡터의 차원(원소의 개수)가 같아야한다
        - 앞의 벡터는 행벡터 뒤의 벡터는 열벡터 이어야 한다
            - numpy에서는 vector끼리 연산시 앞의 벡터는 행벡터로 뒤의 벡터는 열벡터로 인식해 처리한다

 ##### 행렬간의 내적
    - 앞 행렬의 행과 뒤 행렬의 열간에 내적을 한다
    - 행렬과 행렬을 내적하면 그 결과는 행렬이 된다
    - 앞 행렬의 열수와 뒤 행렬의 행수가 같아야 한다
    - 내적의 결과의 형태(shape)는 앞행렬의 행수와 뒤 행렬의 열의 형태를 가진다

#### 범용함수(Ufunc, Universal function)

   ##### 범용함수란
        - 벡터화를 지원하는 넘파이 연산 함수들
            - 유니버셜 뜻이 "전체에 영향을 미치는" 이다. 그래서 이 함수는 배열의 원소 전체에 영햐을 미치는 기능을 제공하는 함수다
            - 배열의 원소별로 연산을 처리하는 함수들
         - 반복문을 사용해 연산하는 것보다 유니버셜 함수를 사용하는 것이 속도가 빠르다
      
   ##### 주요함수
   
   ###### 단항 범용함수(unary ufunc)
        - 매개변수로 한개의 배열을 받는다
        - 한 배열내의 원소별로 연산
  ![다운로드](https://user-images.githubusercontent.com/76146752/108631036-5b01b400-74ab-11eb-8d0c-a8918330e91e.png)
  
  
   ###### 이항 범용함수
        - 매개변수로 두 개의 배열을 받는다
        - 같은 index 원소별로 연산
   ![다운로드 (1)](https://user-images.githubusercontent.com/76146752/108644471-72b05b00-74f2-11eb-825e-491987cdd1a6.png)
   
   ###### 연산결과 출력 지정
        - 연산결과를 특정 배열에 넣을 수 있다
      
        ex) a= np.arange(11,20).reshape(3,3)
            b = np.arange(21,30).reshape(3,3)
            a.shape, b.shape
            
            out = np.zeros((3,3))
            np.add(a,b,out=out) => 계산한 결과값이 out에 들어감
            
 #### 누적연산함수 - reduce()
    - 결과가 하나만 남을 때 까지 해당 연산을 배열의 모든 요소에 반복해서 적용
    - 구문
        - np.이항범용함수이름.reduce(배열, axis=0)
    - 처리결과의 축의 개수(rank)는 하나 줄어든다
        - 1차원 -> 스칼라
            * ex) a= np.arange(1,11)
                np.add.reduce(a) => 배열 a에 있는 모든 원소를 더함(다른 연산도 똑같이 적용)
        - 2차원 -> 1차원
        - 3차원 -> 2차원
        - n차원 -> n-1차원
            ex) x = np.arange(1,13).reshape(3,4) => 다차원 배열의 경우 어느 방향으로 더할지 정할수 있음 
                np.add.reduce(x,1) => 축1번 방향으로 더함
                np.add.reduce(x) => 기본값 0번 축 기준
   
 #### 누적연산함수 - accumulate()
    - 배열의 원소들에 해당 연산을 누적해 적용
    - 처리경과의 축의 개수(rank)는 피연산자배열과 동일하다
    - 구문
        - np.이항범용함수이름.accumulate(배열, axis=0)

#### 기술통계함수
    - 통계결과를 계산해주는 함수들
    - 구문
        1. np.전용함수(배열)
            -np.sum(x)
        2. 일부는 배열.전용함수() 구문 지원
            - x.sum()
    - 배열의 원소 중 누락된 값(NaN -Not  Number) 있을 경우 연산결과는 NaN으로 나온다
    - 안전모드 함수
        - 배열내 누락된 값(NaN)을 무시하고 계산
        - NaN이 연산에 포함 될 경우 결과값은 무조건 NaN이 나오기 때문
        
   ![다운로드 (2)](https://user-images.githubusercontent.com/76146752/108646009-e9038c00-74f7-11eb-932a-bedb4e2504cd.png)

     - 중앙값은 대표값으로 평균이 배열 전체를 대표하기 적절하지 않을 경우 대표값으로 사용됨
        -median -중앙수
        - np.median(배열)
        - 오름차순으로 정렬한 뒤 가우데 위치한 값
        - 배열내 원소들 중에서 이상치(극단값)이 있을 경우 평균을 대신하여 대푯값으로 사용됨
     - 분위수: 중앙값에서 확장된 개념으로 10분의 1에 위치한수 5분의 1에 위치한 수를 조회할 수 있음 
        - np.quantile()
        - 오름차순 정렬 후 특정 위치에 있는 값을 조회
        - 4 분위수 25,50,75 으로 이루어짐

#### boolean 연산을 이용한 처리
    - np.sum(배열에 대한 조건): 조건을 만족하는 원소의 개수
    - np.mean(배열에 대한 조건): 전체중에 조건을 만족하는 원소의 비율 0~1
    - ex) np.sum(boolean 연산) => boolean 연산을 만족하는 원소의 수를 구할 수 있음

#### 브로드캐스팅
    - 사전적의미 : 퍼트린다 전파한다
    - 형태(shape)가 다른 배열 연산시 배열의 형태를 맞춰 연산이 가능하도록 한다
        - 모든 형태를 다 맞추는 것은 아니고 조건이 맞는 배열들끼리 연산 가능
    - 조건
        1. 두 배열의 축의 개수가 다르면 작은 축의 개수를 가진 배열의 형태(shape)의 앞쪽을 1로 채운다
            ex) (2,3) + (3,) => (2,3) + (1,3)
            
        2. 두 배열의 차원 수가 같지만 각 차원의 크기가 다른 경우 어느 한쪽에 1이 있으면 그 1이 다른 배열의 크기와 일치하도록 늘어난다
            - 1이외의 나머지 축의 크기는 같아야하고 1이 아닌 축은 변경 불가능
            - 늘리면서 원소는 그대로 복사한다
            ex) (2,3) +(1,3) => (2,3) + (2,3)
                cf ) (2,3) + (3,3) 의 경우 1이 아니므로 변경 불가 => 연산 불가

